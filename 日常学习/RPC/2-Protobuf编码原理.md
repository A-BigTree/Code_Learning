# Protobuf编码原理

[toc]

---

## 1 前言

Protobuf的编码是基于变种的Base128的，在学习Protobuf编码或者是Base128之前，我们先来了解下Base64编码。



## 2 什么是Base64

### 2.1 技术背景

当我们在计算机之间传输数据时，数据本质上是一串字节流。TCP 协议可以保证被发送的字节流正确地达到目的地（至少在出错时有一定的纠错机制），所以本文不讨论因网络因素造成的数据损坏。

但数据到达目标机器之后，由于不同机器采用的字符集不同等原因，我们并不能保证目标机器能够正确地“理解”字节流。Base 64 最初被设计用于在邮件中嵌入文件（作为 MIME 的一部分）：它可以将任何形式的字节流编码为“安全”的字节流。

**何为“安全“的字节？**先来看看 Base 64 是如何工作的。

### 2.2 工作原理

假设这里有四个字节，代表要传输的数据：

 ```bash
 10100010  00001001  11000010  11010011
 ```

首先将这字节流按每 6 个 bit 为一组进行分组，剩下少于 6 bits 的低位补 0：

```bash
101000  100000  100111  000010  110100  110000
```

**然后在每一组 6 bits 的高位补两个 0：**

```bash
00101000  00100000  00100111  00000010  00110100  00110000
```

Base 64编码对照表如下图：

<img src="./2-Protobuf编码原理.assets/截屏2023-07-03 21.18.37.png" alt="截屏2023-07-03 21.18.37" style="zoom: 67%;" />

对照Base 64的编码对照表，字节流可以用`ognC0w`来表示。

**另外：**Base64 编码是按照 6 bits 为一组进行编码，每 3 个字节的原始数据要用 4 个字节来储存，编码后的长度要为 4 的整数倍，不足 4 字节的部分要使用 pad 补齐，所以最终的编码结果为`ognC0w==`；

任意的字节流均可以使用 Base 64 进行编码，编码之后所有字节均可以用`数字`、`字母`和 `+ / =` 号进行表示，这些都是可以被正常显示的 `ascii` 字符，即“安全”的字节。绝大部分的计算机和操作系统都对 ascii 有着良好的支持，保证了编码之后的字节流能被正确地复制、传播、解析。



## 3 什么是Base 128

**Base 64 存在的问题就是：**编码后的每一个字节的最高两位总是 0，在不考虑 pad 的情况下，有效 bit 只占 bit 总数的 75%，造成大量的空间浪费。

**是否可以进一步提高信息密度呢？**

意识到这一点，你就很自然能想象出 Base 128 的大致实现思路了：将字节流按 7 bits 进行分组，然后低位补 0。**但问题来了：**Base 64 实际上用了 64+1 个 ascii 字符，按照这个思路 Base 128 需要使用 128+1 个 ascii 个字符，但是 ascii 字符一共只有 128 个。

**另外：**即使不考虑 pad，ascii 中包含了一些不可以正常打印的控制字符，编码之后的字符还可能包含会被不同操作系统转换的换行符号（10 和 13）。因此，Base 64 至今依然没有被 Base 128 替代。

Base 64 的规则因为上述限制不能完美地扩展到 Base 128，所以现有基于 Base 64 扩展而来的编码方式大部分都属于变种：如 LEB128（Little-Endian Base 128）、 Base 85 （Ascii 85），以及本文的主角：Base 128 Varints。



